---
title: 46. 全排列
shortTitle: 46. 全排列
category:
  - 力扣
tag:
  - 力扣
---

## [46.全排列](https://leetcode.cn/problems/permutations/?envType=study-plan-v2&envId=top-100-liked)

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

**提示：**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**

代码示例

```go
var (
	ans  [][]int
	path []int
)

func permute(nums []int) [][]int {
	used := make([]bool, len(nums))
	ans, path = make([][]int, 0), make([]int, 0)
	return backtracing(nums, used)
}

func backtracing(nums []int, used []bool) [][]int {
	if len(nums) == len(path) {
		ans = append(ans, slices.Clone(path))
		return ans
	}
	for i := 0; i < len(nums); i++ {
		if !used[i] {
			path = append(path, nums[i])
			used[i] = true
			backtracing(nums, used)
			used[i] = false
			path = path[:len(path)-1]
		}
	}
	return ans
}
```

