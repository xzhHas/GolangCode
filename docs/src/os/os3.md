---
title: cache写策略 操作系统
shortTitle: 3.cache写策略
date: 2024-09-01
category:
  - 操作系统
tag:
  - 操作系统
---

## cache写策略 操作系统

在计算机系统中，为了提高数据的响应速度在CPU内置了cache，用来提高CPU和主存的交互。以下主要是对cache的理解。

### 1、cache写策略

cache是主存里数据的副本。cache的写策略，又分为两种：

- 写直达
- 写回

#### 1.写直达



- 如果数据已经在Cache里，就更新到Cache Block，再写到内存里；
- 否则的话就把直接更新到内存中，读的时候直接读取内存；

写直达简单、直观，但是性能不高。

#### 2.写回

<img src="https://cdn.golangcode.cn/images/202501182151475.png" alt="image-20241112110201050" style="zoom:67%;" />

- 写命中：CPU直接将数据写入到Cache Block中，将该Cache Block的脏位设置为1，表示该数据已经被修改，但主存中的对应数据尚未更新，可以减少不必要的写操作。
- 写未命中
  - Cache Block为脏：在新数据写入缓存前，先将脏的Cache Block中的旧数据写回主存，以确保主存中保存最新的数据。然后将要写入的数据从主存中读取到Cache Block，并将新数据写入该块，将脏位设置为1，标记数据已被修改。
  - Cache Block不为脏：直接将需要的数据从主存载入到Cache Block，并写入新的数据。同样，将脏位设置为1，表示数据已修改，但主存中尚未更新。

在写回机制中，新的数据仅仅被写入到Cache Block里，只有当修改过的Cache Block被替换时才需要写到内存中。

Cache机制就是为了让CPU在处理数据时不总是访问主存，尽可能从更靠近CPU的存储位置获取数据。

### 2、缓存一致性

问题：在一个多核的CPU中，比如四核的CPU，我在1号核心执行i++，但是2号核心使用i的时候是0，这表示了在一号核心计算后的结果并未同步到其他核心，那么就会导致执行结果错误。

- CPU核心的Cache数据同步问题
- CPU核心的数据操作顺序问题

对于第一个问题，解决方法就是写传播的方式，当某个CPU核心更新了Cache里的数据，就把该事件广播到其他核心。

那么这个方法就是总线嗅探。

#### 1.总线嗅探

每个CPU都会监听总线上的广播事件，及时更新自己Cache的数据，但是不能保证操作数据的顺序。所以又有基于总线嗅探的协议MESI协议。

#### 2.MESI协议

- Modified：已修改
  - 该缓存行中的数据已被修改，与主存中的数据不一致，且该数据只存在于当前缓存中。如果其他核心需要该数据，需要先将其写回主存。
- Exclusive：独占
  - 该缓存行中的数据与主存一致，且只存在于当前缓存中。如果当前核心修改了该数据，则状态将转变为Modified。
- Shared：共享
  - 该缓存行中的数据与主存一致，且该数据可能存在于多个缓存中。可以被读取，但如果要修改，需要先通知其他核心，使其无效。
- Invalidated：已失效
  - 该缓存行中的数据无效，不可使用。如果当前核心需要访问此数据，则需要从其他缓存或主存中重新加载。

**MESI协议状态转换行为表**

| 当前状态     | 事件         | 行为                                                         | 转换后状态 |
| ------------ | ------------ | ------------------------------------------------------------ | ---------- |
| **无效 (I)** | Local Read   | 如果其他核心没有该数据，则从主存中加载数据，状态变为Exclusive；如果其他核心有该数据，则状态变为Shared。 | E 或 S     |
|              | Local Write  | 从主存加载数据到Cache并修改，将状态设置为Modified            | M          |
|              | Remote Read  | 保持无效，其他核心读取无影响                                 | I          |
|              | Remote Write | 保持无效，其他核心写入无影响                                 | I          |
| **独占 (E)** | Local Read   | 从Cache中读取数据，状态保持不变                              | E          |
|              | Local Write  | 修改数据，将状态设置为Modified                               | M          |
|              | Remote Read  | 将数据共享给请求的核心，状态变为Shared                       | S          |
|              | Remote Write | 使当前Cache行无效，状态变为Invalid                           | I          |
| **共享 (S)** | Local Read   | 从Cache中读取数据，状态保持不变                              | S          |
|              | Local Write  | 修改数据，将状态设置为Modified                               | M          |
|              | Remote Read  | 共享数据给请求的核心，状态保持不变                           | S          |
|              | Remote Write | 其他核心写入数据，当前Cache行失效，状态变为Invalid           | I          |
| **修改 (M)** | Local Read   | 从Cache中读取数据，状态保持不变                              | M          |
|              | Local Write  | 修改数据，状态保持不变                                       | M          |
|              | Remote Read  | 将数据写回主存以更新，再共享给请求的核心，状态变为Shared     | S          |
|              | Remote Write | 将数据写回主存以更新，然后将当前Cache行失效，状态变为Invalid | I          |

